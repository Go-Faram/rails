<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>Active Record 关联 - Rails 指南</title>
    <meta name="viewport" content="width=device-width" />
    <script src="http://docs-china.com/rails/scripts/docs.js"></script>
    <link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.1/css/bootstrap.min.css" />
    <link rel="stylesheet" href="http://docs-china.com/rails/scripts/docs.css" />
</head>
<body>
    <a class="sr-only" href="#content">跳到正文</a>

    <nav class="navbar navbar-static-top docs-nav" id="top">
        <div class="container">
            <div class="navbar-header">
                <a href="http://docs-china.com" class="navbar-brand" title="回到首页">&larr; Docs China</a>
            </div>
        </div>
    </nav>

    <header class="header" role="banner">
        <div class="container">
            <h1 class="logo"><a href="http://docs-china.com/rails/" title="Rails 指南">Rails 指南</a></h1>
            
            <iframe src="http://ghbtns.com/github-btn.html?user=docs-china&repo=rails&type=fork&count=false"
  allowtransparency="true" frameborder="0" scrolling="0" width="62" height="20"></iframe>
            
            <div class="menu-mobile visible-xs">
  <select onchange="if (this.value) window.location.href=this.value">
    <option value="">目录</option>
    
    <optgroup label="起跑">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/getting_started.html">Rails 入门</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="模型">
      


  

  
    
  
    
  
    
  
    
  
    
      <option value="/active_record_basics.html">Active Record 基础</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/migrations.html">Active Record 数据库迁移</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/active_record_validations.html">Active Record 数据验证</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/active_record_callbacks.html">Active Record 回调</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/association_basics.html">Active Record 关联</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/active_record_querying.html">Active Record 查询</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="视图">
      


  

  
    
  
    
  
    
  
    
      <option value="/action_view_overview.html">Action View 基础</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/layouts_and_rendering.html">Layouts and Rendering in Rails</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/form_helpers.html">表单帮助方法</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="控制器">
      


  

  
    
  
    
      <option value="/action_controller_overview.html">Action Controller 简介</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/routing.html">Rails 路由全解</option>
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="深入">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/active_support_core_extensions.html">Active Support 核心扩展</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/i18n.html">Rails 国际化 API</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
      <option value="/action_mailer_basics.html">Action Mailer 基础</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/testing.html">Rails 程序测试指南</option>
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/security.html">Ruby on Rails 安全指南</option>
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/debugging_rails_applications.html">Rails 程序调试</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/configuring.html">Rails 程序设置</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/command_line.html">Rails 命令行</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/caching_with_rails.html">Caching with Rails An overview</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/asset_pipeline.html">Asset Pipeline</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/working_with_javascript_in_rails.html">在 Rails 中使用 JavaScript</option>
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/engines.html">Getting Started with Engines</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/initialization.html">Rails 初始化过程</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="扩展">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/plugins.html">Rails 插件开发基础</option>
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/rails_on_rack.html">Rails on Rack</option>
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/generators.html">Creating and Customizing Rails Generators & Templates</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
  </select>
</div>

        </div>
    </header>

    <div id="content" class="content" role="main">
        <div class="container">
            <div class="row">
                <main class="main col-sm-9 col-md-9">
                    <article class="entry">
                        <h1>Active Record 关联</h1>
                        <p>本文介绍 Active Record 中的关联功能。</p>

<p>读完后，你将学会：</p>

<ul>
  <li>如何声明 Active Record 模型间的关联；</li>
  <li>怎么理解不同的 Active Record 关联类型；</li>
  <li>如何使用关联添加的方法；</li>
</ul>

<hr />

<h2 id="why-associations">为什么要使用关联</h2>

<p>模型之间为什么要有关联？因为关联让常规操作更简单。例如，在一个简单的 Rails 程序中，有一个顾客模型和一个订单模型。每个顾客可以下多个订单。没用关联的模型定义如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
<span class="k">end</span>
</pre>

</div>
<p>假如我们要为一个顾客添加一个订单，得这么做：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">order_date: </span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">,</span> <span class="ss">customer_id: </span><span class="vi">@customer</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span>
</pre>

</div>
<p>或者说要删除一个顾客，确保他的所有订单都会被删除，得这么做：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@orders</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">customer_id: </span><span class="vi">@customer</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span>
<span class="vi">@orders</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">order</span><span class="o">|</span>
  <span class="n">order</span><span class="p">.</span><span class="nf">destroy</span>
<span class="k">end</span>
<span class="vi">@customer</span><span class="p">.</span><span class="nf">destroy</span>
</pre>

</div>
<p>使用 Active Record 关联，告诉 Rails 这两个模型是有一定联系的，就可以把这些操作连在一起。下面使用关联重新定义顾客和订单模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">dependent: :destroy</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
<span class="k">end</span>
</pre>

</div>
<p>这么修改之后，为某个顾客添加新订单就变得简单了：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@order</span> <span class="o">=</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">order_date: </span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">)</span>
</pre>

</div>
<p>删除顾客及其所有订单更容易：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@customer</span><span class="p">.</span><span class="nf">destroy</span>
</pre>

</div>
<p>学习更多关联类型，请阅读下一节。下一节介绍了一些使用关联时的小技巧，然后列出了关联添加的所有方法和选项。</p>

<h2 id="the-types-of-associations">关联的类型</h2>

<p>在 Rails 中，关联是两个 Active Record 模型之间的关系。关联使用宏的方式实现，用声明的形式为模型添加功能。例如，声明一个模型属于（<code>belongs_to</code>）另一个模型后，Rails 会维护两个模型之间的“主键-外键”关系，而且还向模型中添加了很多实用的方法。Rails 支持六种关联：</p>

<ul>
  <li><code>belongs_to</code></li>
  <li><code>has_one</code></li>
  <li><code>has_many</code></li>
  <li><code>has_many :through</code></li>
  <li><code>has_one :through</code></li>
  <li><code>has_and_belongs_to_many</code></li>
</ul>

<p>在后面的几节中，你会学到如何声明并使用这些关联。首先来看一下各种关联适用的场景。</p>

<h3 id="the-belongs-to-association"><code>belongs_to</code> 关联</h3>

<p><code>belongs_to</code> 关联创建两个模型之间一对一的关系，声明所在的模型实例属于另一个模型的实例。例如，如果程序中有顾客和订单两个模型，每个订单只能指定给一个顾客，就要这么声明订单模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
<span class="k">end</span>
</pre>

</div>
<p><img src="http://docs-china.com/rails/images/belongs_to.png" alt="belongs_to 关联" /></p>

          <div class="box information-box">
  <p>在 <code>belongs_to</code> 关联声明中必须使用单数形式。如果在上面的代码中使用复数形式，程序会报错，提示未初始化常量 <code>Order::Customers</code>。因为 Rails 自动使用关联中的名字引用类名。如果关联中的名字错误的使用复数，引用的类也就变成了复数。</p>
</div>


<p>相应的迁移如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateOrders</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:customers</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:orders</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:customer</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">datetime</span> <span class="ss">:order_date</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<h3 id="the-has-one-association"><code>has_one</code> 关联</h3>

<p><code>has_one</code> 关联也会建立两个模型之间的一对一关系，但语义和结果有点不一样。这种关联表示模型的实例包含或拥有另一个模型的实例。例如，在程序中，每个供应商只有一个账户，可以这么定义供应商模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span>
<span class="k">end</span>
</pre>

</div>
<p><img src="http://docs-china.com/rails/images/has_one.png" alt="has_one 关联" /></p>

<p>相应的迁移如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateSuppliers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:suppliers</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:accounts</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:supplier</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:account_number</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<h3 id="the-has-many-association"><code>has_many</code> 关联</h3>

<p><code>has_many</code> 关联建立两个模型之间的一对多关系。在 <code>belongs_to</code> 关联的另一端经常会使用这个关联。<code>has_many</code> 关联表示模型的实例有零个或多个另一个模型的实例。例如，在程序中有顾客和订单两个模型，顾客模型可以这么定义：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>
</pre>

</div>
          <div class="box information-box">
  <p>声明 <code>has_many</code> 关联时，另一个模型使用复数形式。</p>
</div>


<p><img src="http://docs-china.com/rails/images/has_many.png" alt="has_many 关联" /></p>

<p>相应的迁移如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateCustomers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:customers</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:orders</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:customer</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">datetime</span> <span class="ss">:order_date</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<h3 id="the-has-many-through-association"><code>has_many :through</code> 关联</h3>

<p><code>has_many :through</code> 关联经常用来建立两个模型之间的多对多关联。这种关联表示一个模型的实例可以借由第三个模型，拥有零个和多个另一个模型的实例。例如，在医疗锻炼中，病人要和医生约定练习时间。这中间的关联声明如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Physician</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:appointments</span>
  <span class="n">has_many</span> <span class="ss">:patients</span><span class="p">,</span> <span class="ss">through: :appointments</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Appointment</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:physician</span>
  <span class="n">belongs_to</span> <span class="ss">:patient</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Patient</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:appointments</span>
  <span class="n">has_many</span> <span class="ss">:physicians</span><span class="p">,</span> <span class="ss">through: :appointments</span>
<span class="k">end</span>
</pre>

</div>
<p><img src="http://docs-china.com/rails/images/has_many_through.png" alt="has_many :through 关联" /></p>

<p>相应的迁移如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateAppointments</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:physicians</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:patients</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:appointments</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:physician</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:patient</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">datetime</span> <span class="ss">:appointment_date</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>连接模型中的集合可以使用 API 关联。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">physician</span><span class="p">.</span><span class="nf">patients</span> <span class="o">=</span> <span class="n">patients</span>
</pre>

</div>
<p>会为新建立的关联对象创建连接模型实例，如果其中一个对象山粗了，相应的记录也会删除。</p>

          <div class="box warning-box">
  <p>自动删除连接模型的操作直接执行，不会触发 <code>*_destroy</code> 回调。</p>
</div>


<p><code>has_many :through</code> 还可用来简化嵌套的 <code>has_many</code> 关联。例如，一个文档分为多个部分，每一部分又有多个段落，如果想使用简单的方式获取文档中的所有段落，可以这么做：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Document</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:sections</span>
  <span class="n">has_many</span> <span class="ss">:paragraphs</span><span class="p">,</span> <span class="ss">through: :sections</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Section</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:document</span>
  <span class="n">has_many</span> <span class="ss">:paragraphs</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Paragraph</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:section</span>
<span class="k">end</span>
</pre>

</div>
<p>加上 <code>through: :sections</code> 后，Rails 就能理解这段代码：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@document</span><span class="p">.</span><span class="nf">paragraphs</span>
</pre>

</div>
<h3 id="the-has-one-through-association"><code>has_one :through</code> 关联</h3>

<p><code>has_one :through</code> 关联建立两个模型之间的一对一关系。这种关联表示一个模型通过第三个模型拥有另一个模型的实例。例如，每个供应商只有一个账户，而且每个账户都有一个历史账户，那么可以这么定义模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span>
  <span class="n">has_one</span> <span class="ss">:account_history</span><span class="p">,</span> <span class="ss">through: :account</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:supplier</span>
  <span class="n">has_one</span> <span class="ss">:account_history</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">AccountHistory</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:account</span>
<span class="k">end</span>
</pre>

</div>
<p><img src="http://docs-china.com/rails/images/has_one_through.png" alt="has_one :through 关联" /></p>

<p>相应的迁移如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateAccountHistories</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:suppliers</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:accounts</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:supplier</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:account_number</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:account_histories</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:account</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:credit_rating</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<h3 id="the-has-and-belongs-to-many-association"><code>has_and_belongs_to_many</code> 关联</h3>

<p><code>has_and_belongs_to_many</code> 关联之间建立两个模型之间的多对多关系，不借由第三个模型。例如，程序中有装配体和零件两个模型，每个装配体中有多个零件，每个零件又可用于多个装配体，这时可以按照下面的方式定义模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Assembly</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:parts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Part</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span>
<span class="k">end</span>
</pre>

</div>
<p><img src="http://docs-china.com/rails/images/habtm.png" alt="has_and_belongs_to_many 关联" /></p>

<p>相应的迁移如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateAssembliesAndParts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:assemblies</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:parts</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:part_number</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:assemblies_parts</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="kp">false</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:assembly</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:part</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<h3 id="choosing-between-belongs-to-and-has-one">使用 <code>belongs_to</code> 还是 <code>has_one</code></h3>

<p>如果想建立两个模型之间的一对一关系，可以在一个模型中声明 <code>belongs_to</code>，然后在另一模型中声明 <code>has_one</code>。但是怎么知道在哪个模型中声明哪种关联？</p>

<p>不同的声明方式带来的区别是外键放在哪个模型对应的数据表中（外键在声明 <code>belongs_to</code> 关联所在模型对应的数据表中）。不过声明时要考虑一下语义，<code>has_one</code> 的意思是某样东西属于我。例如，说供应商有一个账户，比账户拥有供应商更合理，所以正确的关联应该这么声明：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:supplier</span>
<span class="k">end</span>
</pre>

</div>
<p>相应的迁移如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateSuppliers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:suppliers</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span>  <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>

    <span class="n">create_table</span> <span class="ss">:accounts</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:supplier_id</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span>  <span class="ss">:account_number</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
          <div class="box information-box">
  <p><code>t.integer :supplier_id</code> 更明确的表明了外键的名字。在目前的 Rails 版本中，可以抽象实现的细节，使用 <code>t.references :supplier</code> 代替。</p>
</div>


<h3 id="choosing-between-has-many-through-and-has-and-belongs-to-many">使用 <code>has_many :through</code> 还是 <code>has_and_belongs_to_many</code></h3>

<p>Rails 提供了两种建立模型之间多对多关系的方法。其中比较简单的是 <code>has_and_belongs_to_many</code>，可以直接建立关联：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Assembly</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:parts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Part</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span>
<span class="k">end</span>
</pre>

</div>
<p>第二种方法是使用 <code>has_many :through</code>，但无法直接建立关联，要通过第三个模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Assembly</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:manifests</span>
  <span class="n">has_many</span> <span class="ss">:parts</span><span class="p">,</span> <span class="ss">through: :manifests</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Manifest</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:assembly</span>
  <span class="n">belongs_to</span> <span class="ss">:part</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Part</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:manifests</span>
  <span class="n">has_many</span> <span class="ss">:assemblies</span><span class="p">,</span> <span class="ss">through: :manifests</span>
<span class="k">end</span>
</pre>

</div>
<p>根据经验，如果关联的第三个模型要作为独立实体使用，要用 <code>has_many :through</code> 关联；如果不需要使用第三个模型，用简单的 <code>has_and_belongs_to_many</code> 关联即可（不过要记得在数据库中创建连接数据表）。</p>

<p>如果需要做数据验证、回调，或者连接模型上要用到其他属性，此时就要使用 <code>has_many :through</code> 关联。</p>

<h3 id="polymorphic-associations">多态关联</h3>

<p>关联还有一种高级用法，“多态关联”。在多台关联中，在同一个关联中，模型可以属于其他多个模型。例如，图片模型可以属于雇员模型或者产品模型，模型的定义如下：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Picture</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:imageable</span><span class="p">,</span> <span class="ss">polymorphic: </span><span class="kp">true</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Employee</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:pictures</span><span class="p">,</span> <span class="ss">as: :imageable</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Product</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:pictures</span><span class="p">,</span> <span class="ss">as: :imageable</span>
<span class="k">end</span>
</pre>

</div>
<p>在 <code>belongs_to</code> 中指定使用多态，可以理解成创建了一个借口，可供任何一个模型使用。在 <code>Employee</code> 模型实例上，可以使用 <code>@employee.pictures</code> 获取图片集合。类似地，可使用 <code>@product.pictures</code> 获取产品的图片。</p>

<p>在 <code>Picture</code> 模型的实例上，可以使用 <code>@picture.imageable</code> 获取父对象。不过事先要在声明多态接口的模型中创建外键字段和类型字段：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreatePictures</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:pictures</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span>  <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:imageable_id</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span>  <span class="ss">:imageable_type</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>上面的迁移可以使用 <code>t.references</code> 简化：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreatePictures</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:pictures</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">references</span> <span class="ss">:imageable</span><span class="p">,</span> <span class="ss">polymorphic: </span><span class="kp">true</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p><img src="http://docs-china.com/rails/images/polymorphic.png" alt="多态关联" /></p>

<h3 id="self-joins">自连接</h3>

<p>设计数据模型时会发现，有时模型要和自己建立关联。例如，在一个数据表中保存所有雇员的信息，但要建立经理和下属之间的关系。这种情况可以使用自连接关联解决：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Employee</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:subordinates</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Employee"</span><span class="p">,</span>
                          <span class="ss">foreign_key: </span><span class="s2">"manager_id"</span>

  <span class="n">belongs_to</span> <span class="ss">:manager</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Employee"</span>
<span class="k">end</span>
</pre>

</div>
<p>这样定义模型后，就可以使用 <code>@employee.subordinates</code> 和 <code>@employee.manager</code> 了。</p>

<p>在迁移中，要添加一个引用字段，指向模型自身：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateEmployees</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:employees</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">references</span> <span class="ss">:manager</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<h2 id="tips-tricks-and-warnings">小技巧和注意事项</h2>

<p>在 Rails 程序中高效地使用 Active Record 关联，要了解以下几个知识：</p>

<ul>
  <li>缓存控制</li>
  <li>避免命名冲突</li>
  <li>更新模式</li>
  <li>控制关联的作用域</li>
  <li>Bi-directional associations</li>
</ul>

<h3 id="controlling-caching">缓存控制</h3>

<p>关联添加的方法都会使用缓存，记录最近一次查询结果，以备后用。缓存还会在方法之间共享。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">customer</span><span class="p">.</span><span class="nf">orders</span>                 <span class="c1"># retrieves orders from the database</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">size</span>            <span class="c1"># uses the cached copy of orders</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">empty?</span>          <span class="c1"># uses the cached copy of orders</span>
</pre>

</div>
<p>程序的其他部分会修改数据，那么应该怎么重载缓存呢？调用关联方法时传入 <code>true</code> 参数即可：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">customer</span><span class="p">.</span><span class="nf">orders</span>                 <span class="c1"># retrieves orders from the database</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">size</span>            <span class="c1"># uses the cached copy of orders</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">(</span><span class="kp">true</span><span class="p">).</span><span class="nf">empty?</span>    <span class="c1"># discards the cached copy of orders</span>
                                <span class="c1"># and goes back to the database</span>
</pre>

</div>
<h3 id="avoiding-name-collisions">避免命名冲突</h3>

<p>关联的名字并不能随意使用。因为创建关联时，会向模型添加同名方法，所以关联的名字不能和 <code>ActiveRecord::Base</code> 中的实例方法同名。如果同名，关联方法会覆盖 <code>ActiveRecord::Base</code> 中的实例方法，导致错误。例如，关联的名字不能为 <code>attributes</code> 或 <code>connection</code>。</p>

<h3 id="updating-the-schema">更新模式</h3>

<p>关联非常有用，但没什么魔法。关联对应的数据库模式需要你自己编写。不同的关联类型，要做的事也不同。对 <code>belongs_to</code> 关联来说，要创建外键；对 <code>has_and_belongs_to_many</code> 来说，要创建相应的连接数据表。</p>

<h4 id="creating-foreign-keys-for-belongs-to-associations">创建 <code>belongs_to</code> 关联所需的外键</h4>

<p>声明 <code>belongs_to</code> 关联后，要创建相应的外键。例如，有下面这个模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
<span class="k">end</span>
</pre>

</div>
<p>这种关联需要在数据表中创建合适的外键：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateOrders</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:orders</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">datetime</span> <span class="ss">:order_date</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span>   <span class="ss">:order_number</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span>  <span class="ss">:customer_id</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>如果声明关联之前已经定义了模型，则要在迁移中使用 <code>add_column</code> 创建外键。</p>

<h4 id="creating-join-tables-for-has-and-belongs-to-many-associations">创建 <code>has_and_belongs_to_many</code> 关联所需的连接数据表</h4>

<p>声明 <code>has_and_belongs_to_many</code> 关联后，必须手动创建连接数据表。除非在 <code>:join_table</code> 选项中指定了连接数据表的名字，否则 Active Record 会按照类名出现在字典中的顺序为数据表起名字。那么，顾客和订单模型使用的连接数据表默认名为“customers_orders”，因为在字典中，“c”在“o”前面。</p>

          <div class="box warning-box">
  <p>模型名的顺序使用字符串的 <code>&lt;</code> 操作符确定。所以，如果两个字符串的长度不同，比较最短长度时，两个字符串是相等的，但长字符串的排序比短字符串靠前。例如，你可能以为“”paper_boxes”和“papers”这两个表生成的连接表名为“papers_paper_boxes”，因为“paper_boxes”比“papers”长。其实生成的连接表名为“paper_boxes_papers”，因为在一般的编码方式中，“_”比“s”靠前。</p>
</div>


<p>不管名字是什么，你都要在迁移中手动创建连接数据表。例如下面的关联声明：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Assembly</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:parts</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Part</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span>
<span class="k">end</span>
</pre>

</div>
<p>需要在迁移中创建 <code>assemblies_parts</code> 数据表，而且该表无主键：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">CreateAssembliesPartsJoinTable</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:assemblies_parts</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="kp">false</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:assembly_id</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:part_id</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>我们把 <code>id: false</code> 选项传给 <code>create_table</code> 方法，因为这个表不对应模型。只有这样，关联才能正常建立。如果在使用 <code>has_and_belongs_to_many</code> 关联时遇到奇怪的表现，例如提示模型 ID 损坏，或 ID 冲突，有可能就是因为创建了主键。</p>

<h3 id="controlling-association-scope">控制关联的作用域</h3>

<p>默认情况下，关联只会查找当前模块作用域中的对象。如果在模块中定义 Active Record 模型，知道这一点很重要。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">module</span> <span class="nn">MyApplication</span>
  <span class="k">module</span> <span class="nn">Business</span>
    <span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
       <span class="n">has_one</span> <span class="ss">:account</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
       <span class="n">belongs_to</span> <span class="ss">:supplier</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>上面的代码能正常运行，因为 <code>Supplier</code> 和 <code>Account</code> 在同一个作用域内。但下面这段代码就不行了，因为 <code>Supplier</code> 和 <code>Account</code> 在不同的作用域中：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">module</span> <span class="nn">MyApplication</span>
  <span class="k">module</span> <span class="nn">Business</span>
    <span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
       <span class="n">has_one</span> <span class="ss">:account</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">module</span> <span class="nn">Billing</span>
    <span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
       <span class="n">belongs_to</span> <span class="ss">:supplier</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>要想让处在不同命名空间中的模型正常建立关联，声明关联时要指定完整的类名：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">module</span> <span class="nn">MyApplication</span>
  <span class="k">module</span> <span class="nn">Business</span>
    <span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
       <span class="n">has_one</span> <span class="ss">:account</span><span class="p">,</span>
        <span class="ss">class_name: </span><span class="s2">"MyApplication::Billing::Account"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">module</span> <span class="nn">Billing</span>
    <span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
       <span class="n">belongs_to</span> <span class="ss">:supplier</span><span class="p">,</span>
        <span class="ss">class_name: </span><span class="s2">"MyApplication::Business::Supplier"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<h3 id="bi-directional-associations">双向关联</h3>

<p>一般情况下，都要求能在关联的两端进行操作。例如，有下面的关联声明：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
<span class="k">end</span>
</pre>

</div>
<p>默认情况下，Active Record 并不知道这个关联中两个模型之间的联系。可能导致同一对象的两个副本不同步：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">c</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span>
<span class="n">o</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">first</span>
<span class="n">c</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="nf">customer</span><span class="p">.</span><span class="nf">first_name</span> <span class="c1"># =&gt; true</span>
<span class="n">c</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s1">'Manny'</span>
<span class="n">c</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="nf">customer</span><span class="p">.</span><span class="nf">first_name</span> <span class="c1"># =&gt; false</span>
</pre>

</div>
<p>之所以会发生这种情况，是因为 <code>c</code> 和 <code>o.customer</code> 在内存中是同一数据的两钟表示，修改其中一个并不会刷新另一个。Active Record 提供了 <code>:inverse_of</code> 选项，可以告知 Rails 两者之间的关系：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">inverse_of: :customer</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">inverse_of: :orders</span>
<span class="k">end</span>
</pre>

</div>
<p>这么修改之后，Active Record 就只会加载一个顾客对象，避免数据的不一致性，提高程序的执行效率：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">c</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span>
<span class="n">o</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">first</span>
<span class="n">c</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="nf">customer</span><span class="p">.</span><span class="nf">first_name</span> <span class="c1"># =&gt; true</span>
<span class="n">c</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s1">'Manny'</span>
<span class="n">c</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="nf">customer</span><span class="p">.</span><span class="nf">first_name</span> <span class="c1"># =&gt; true</span>
</pre>

</div>
<p><code>inverse_of</code> 有些限制：</p>

<ul>
  <li>不能和 <code>:through</code> 选项同时使用；</li>
  <li>不能和 <code>:polymorphic</code> 选项同时使用；</li>
  <li>不能和 <code>:as</code> 选项同时使用；</li>
  <li>在 <code>belongs_to</code> 关联中，会忽略 <code>has_many</code> 关联的 <code>inverse_of</code> 选项；</li>
</ul>

<p>每种关联都会尝试自动找到关联的另一端，设置 <code>:inverse_of</code> 选项（根据关联的名字）。使用标准名字的关联都有这种功能。但是，如果在关联中设置了下面这些选项，将无法自动设置 <code>:inverse_of</code>：</p>

<ul>
  <li><code>:conditions</code></li>
  <li><code>:through</code></li>
  <li><code>:polymorphic</code></li>
  <li><code>:foreign_key</code></li>
</ul>

<h2 id="detailed-association-reference">关联详解</h2>

<p>下面几节详细说明各种关联，包括添加的方法和声明关联时可以使用的选项。</p>

<h3 id="belongs-to-association-reference"><code>belongs_to</code> 关联详解</h3>

<p><code>belongs_to</code> 关联创建一个模型与另一个模型之间的一对一关系。用数据库的行话来说，就是这个类中包含了外键。如果外键在另一个类中，就应该使用 <code>has_one</code> 关联。</p>

<h4 id="methods-added-by-belongs-to"><code>belongs_to</code> 关联添加的方法</h4>

<p>声明  <code>belongs_to</code> 关联后，所在的类自动获得了五个和关联相关的方法：</p>

<ul>
  <li><code>association(force_reload = false)</code></li>
  <li><code>association=(associate)</code></li>
  <li><code>build_association(attributes = {})</code></li>
  <li><code>create_association(attributes = {})</code></li>
  <li><code>create_association!(attributes = {})</code></li>
</ul>

<p>这五个方法中的 <code>association</code> 要替换成传入 <code>belongs_to</code> 方法的第一个参数。例如，如下的声明：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
<span class="k">end</span>
</pre>

</div>
<p>每个 <code>Order</code> 模型实例都获得了这些方法：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">customer</span>
<span class="n">customer</span><span class="o">=</span>
<span class="n">build_customer</span>
<span class="n">create_customer</span>
<span class="n">create_customer!</span>
</pre>

</div>
          <div class="box information-box">
  <p>在 <code>has_one</code> 和 <code>belongs_to</code> 关联中，必须使用 <code>build_*</code> 方法构建关联对象。<code>association.build</code> 方法是在 <code>has_many</code> 和 <code>has_and_belongs_to_many</code> 关联中使用的。创建关联对象要使用 <code>create_*</code> 方法。</p>
</div>


<h5 id="methods-added-by-belongs-to-association-force-reload-false"><code>association(force_reload = false)</code></h5>

<p>如果关联的对象存在，<code>association</code> 方法会返回关联对象。如果找不到关联对象，则返回 <code>nil</code>。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@customer</span> <span class="o">=</span> <span class="vi">@order</span><span class="p">.</span><span class="nf">customer</span>
</pre>

</div>
<p>如果关联对象之前已经取回，会返回缓存版本。如果不想使用缓存版本，强制重新从数据库中读取，可以把 <code>force_reload</code> 参数设为 <code>true</code>。</p>

<h5 id="methods-added-by-belongs-to-association-associate"><code>association=(associate)</code></h5>

<p><code>association=</code> 方法用来赋值关联的对象。这个方法的底层操作是，从关联对象上读取主键，然后把值赋给该主键对应的对象。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@order</span><span class="p">.</span><span class="nf">customer</span> <span class="o">=</span> <span class="vi">@customer</span>
</pre>

</div>
<h5 id="methods-added-by-belongs-to-build-association-attributes"><code>build_association(attributes = {})</code></h5>

<p><code>build_association</code> 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，但关联对象不会存入数据库。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@customer</span> <span class="o">=</span> <span class="vi">@order</span><span class="p">.</span><span class="nf">build_customer</span><span class="p">(</span><span class="ss">customer_number: </span><span class="mi">123</span><span class="p">,</span>
                                  <span class="ss">customer_name: </span><span class="s2">"John Doe"</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-belongs-to-create-association-attributes"><code>create_association(attributes = {})</code></h5>

<p><code>create_association</code> 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，只要能通过所有数据验证，就会把关联对象存入数据库。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@customer</span> <span class="o">=</span> <span class="vi">@order</span><span class="p">.</span><span class="nf">create_customer</span><span class="p">(</span><span class="ss">customer_number: </span><span class="mi">123</span><span class="p">,</span>
                                   <span class="ss">customer_name: </span><span class="s2">"John Doe"</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-belongs-to-create-association-bang-attributes"><code>create_association!(attributes = {})</code></h5>

<p>和 <code>create_association</code> 方法作用相同，但是如果记录不合法，会抛出 <code>ActiveRecord::RecordInvalid</code> 异常。</p>

<h4 id="options-for-belongs-to"><code>belongs_to</code> 方法的选项</h4>

<p>Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 <code>belongs_to</code> 关联的行为。定制的方法很简单，声明关联时传入选项或者使用代码块即可。例如，下面的关联使用了两个选项：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">dependent: :destroy</span><span class="p">,</span>
    <span class="ss">counter_cache: </span><span class="kp">true</span>
<span class="k">end</span>
</pre>

</div>
<p><code>belongs_to</code> 关联支持以下选项：</p>

<ul>
  <li><code>:autosave</code></li>
  <li><code>:class_name</code></li>
  <li><code>:counter_cache</code></li>
  <li><code>:dependent</code></li>
  <li><code>:foreign_key</code></li>
  <li><code>:inverse_of</code></li>
  <li><code>:polymorphic</code></li>
  <li><code>:touch</code></li>
  <li><code>:validate</code></li>
</ul>

<h5 id="options-for-belongs-to-autosave"><code>:autosave</code></h5>

<p>如果把 <code>:autosave</code> 选项设为 <code>true</code>，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。</p>

<h5 id="options-for-belongs-to-class-name"><code>:class_name</code></h5>

<p>如果另一个模型无法从关联的名字获取，可以使用 <code>:class_name</code> 选项指定模型名。例如，如果订单属于顾客，但表示顾客的模型是 <code>Patron</code>，就可以这样声明关联：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Patron"</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="options-for-belongs-to-counter-cache"><code>:counter_cache</code></h5>

<p><code>:counter_cache</code> 选项可以提高统计所属对象数量操作的效率。假如如下的模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
<span class="k">end</span>
<span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>
</pre>

</div>
<p>这样声明关联后，如果想知道 <code>@customer.orders.size</code> 的结果，就要在数据库中执行 <code>COUNT(*)</code> 查询。如果不想执行这个查询，可以在声明 <code>belongs_to</code> 关联的模型中加入计数缓存功能：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">counter_cache: </span><span class="kp">true</span>
<span class="k">end</span>
<span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>
</pre>

</div>
<p>这样声明关联后，Rails 会及时更新缓存，调用 <code>size</code> 方法时返回缓存中的值。</p>

<p>虽然 <code>:counter_cache</code> 选项在声明 <code>belongs_to</code> 关联的模型中设置，但实际使用的字段要添加到关联的模型中。针对上面的例子，要把 <code>orders_count</code> 字段加入 <code>Customer</code> 模型。这个字段的默认名也是可以设置的：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">counter_cache: :count_of_orders</span>
<span class="k">end</span>
<span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>
</pre>

</div>
<p>计数缓存字段通过 <code>attr_readonly</code> 方法加入关联模型的只读属性列表中。</p>

<h5 id="options-for-belongs-to-dependent"><code>:dependent</code></h5>

<p><code>:dependent</code> 选项的值有两个：</p>

<ul>
  <li><code>:destroy</code>：销毁对象时，也会在关联对象上调用 <code>destroy</code> 方法；</li>
  <li><code>:delete</code>：销毁对象时，关联的对象不会调用 <code>destroy</code> 方法，而是直接从数据库中删除；</li>
</ul>

          <div class="box warning-box">
  <p>在 <code>belongs_to</code> 关联和 <code>has_many</code> 关联配对时，不应该设置这个选项，否则会导致数据库中出现孤儿记录。</p>
</div>


<h5 id="options-for-belongs-to-foreign-key"><code>:foreign_key</code></h5>

<p>按照约定，用来存储外键的字段名是关联名后加 <code>_id</code>。<code>:foreign_key</code> 选项可以设置要使用的外键名：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Patron"</span><span class="p">,</span>
                        <span class="ss">foreign_key: </span><span class="s2">"patron_id"</span>
<span class="k">end</span>
</pre>

</div>
          <div class="box tip-box">
  <p>不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。</p>
</div>


<h5 id="options-for-belongs-to-inverse-of"><code>:inverse_of</code></h5>

<p><code>:inverse_of</code> 选项指定 <code>belongs_to</code> 关联另一端的 <code>has_many</code> 和 <code>has_one</code> 关联名。不能和 <code>:polymorphic</code> 选项一起使用。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">inverse_of: :customer</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">inverse_of: :orders</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="polymorphic"><code>:polymorphic</code></h5>

<p><code>:polymorphic</code> 选项为 <code>true</code> 时表明这是个多态关联。<a href="#polymorphic-associations">前文</a>已经详细介绍过多态关联。</p>

<h5 id="touch"><code>:touch</code></h5>

<p>如果把 <code>:touch</code> 选项设为 <code>true</code>，保存或销毁对象时，关联对象的 <code>updated_at</code> 或 <code>updated_on</code> 字段会自动设为当前时间戳。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">touch: </span><span class="kp">true</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>
</pre>

</div>
<p>在这个例子中，保存或销毁订单后，会更新关联的顾客中的时间戳。还可指定要更新哪个字段的时间戳：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">touch: :orders_updated_at</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="options-for-belongs-to-validate"><code>:validate</code></h5>

<p>如果把 <code>:validate</code> 选项设为 <code>true</code>，保存对象时，会同时验证关联对象。该选项的默认值是 <code>false</code>，保存对象时不验证关联对象。</p>

<h4 id="scopes-for-belongs-to"><code>belongs_to</code> 的作用域</h4>

<p>有时可能需要定制 <code>belongs_to</code> 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">active: </span><span class="kp">true</span> <span class="p">},</span>
                        <span class="ss">dependent: :destroy</span>
<span class="k">end</span>
</pre>

</div>
<p>在作用域代码块中可以使用任何一个标准的<a href="http://docs-china.com/rails/active_record_querying.html">查询方法</a>。下面分别介绍这几个方法：</p>

<ul>
  <li><code>where</code></li>
  <li><code>includes</code></li>
  <li><code>readonly</code></li>
  <li><code>select</code></li>
</ul>

<h5 id="scopes-for-belongs-to-where"><code>where</code></h5>

<p><code>where</code> 方法指定关联对象必须满足的条件。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">active: </span><span class="kp">true</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-belongs-to-includes"><code>includes</code></h5>

<p><code>includes</code> 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">LineItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:order</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">has_many</span> <span class="ss">:line_items</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>
</pre>

</div>
<p>如果经常要直接从商品上获取顾客对象（<code>@line_item.order.customer</code>），就可以把顾客引入商品和订单的关联中：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">LineItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:order</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">includes</span> <span class="ss">:customer</span> <span class="p">}</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">has_many</span> <span class="ss">:line_items</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>
</pre>

</div>
          <div class="box information-box">
  <p>直接关联没必要使用 <code>includes</code>。如果 <code>Order belongs_to :customer</code>，那么顾客会自动按需加载。</p>
</div>


<h5 id="scopes-for-belongs-to-readonly"><code>readonly</code></h5>

<p>如果使用 <code>readonly</code>，通过关联获取的对象就是只读的。</p>

<h5 id="scopes-for-belongs-to-select"><code>select</code></h5>

<p><code>select</code> 方法会覆盖获取关联对象使用的 SQL <code>SELECT</code> 子句。默认情况下，Rails 会读取所有字段。</p>

          <div class="box tip-box">
  <p>如果在 <code>belongs_to</code> 关联中使用 <code>select</code> 方法，应该同时设置 <code>:foreign_key</code> 选项，确保返回正确的结果。</p>
</div>


<h4 id="belongs-to-association-reference-do-any-associated-objects-exist-questionmark">检查关联的对象是否存在</h4>

<p>检查关联的对象是否存在可以使用 <code>association.nil?</code> 方法：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">if</span> <span class="vi">@order</span><span class="p">.</span><span class="nf">customer</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="vi">@msg</span> <span class="o">=</span> <span class="s2">"No customer found for this order"</span>
<span class="k">end</span>
</pre>

</div>
<h4 id="belongs-to-association-reference-when-are-objects-saved-questionmark">什么时候保存对象</h4>

<p>把对象赋值给 <code>belongs_to</code> 关联不会自动保存对象，也不会保存关联的对象。</p>

<h3 id="has-one-association-reference"><code>has_one</code> 关联详解</h3>

<p><code>has_one</code> 关联建立两个模型之间的一对一关系。用数据库的行话说，这种关联的意思是外键在另一个类中。如果外键在这个类中，应该使用 <code>belongs_to</code> 关联。</p>

<h4 id="methods-added-by-has-one"><code>has_one</code> 关联添加的方法</h4>

<p>声明 <code>has_one</code> 关联后，声明所在的类自动获得了五个关联相关的方法：</p>

<ul>
  <li><code>association(force_reload = false)</code></li>
  <li><code>association=(associate)</code></li>
  <li><code>build_association(attributes = {})</code></li>
  <li><code>create_association(attributes = {})</code></li>
  <li><code>create_association!(attributes = {})</code></li>
</ul>

<p>这五个方法中的 <code>association</code> 要替换成传入 <code>has_one</code> 方法的第一个参数。例如，如下的声明：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span>
<span class="k">end</span>
</pre>

</div>
<p>每个 <code>Supplier</code> 模型实例都获得了这些方法：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">account</span>
<span class="n">account</span><span class="o">=</span>
<span class="n">build_account</span>
<span class="n">create_account</span>
<span class="n">create_account!</span>
</pre>

</div>
          <div class="box information-box">
  <p>在 <code>has_one</code> 和 <code>belongs_to</code> 关联中，必须使用 <code>build_*</code> 方法构建关联对象。<code>association.build</code> 方法是在 <code>has_many</code> 和 <code>has_and_belongs_to_many</code> 关联中使用的。创建关联对象要使用 <code>create_*</code> 方法。</p>
</div>


<h5 id="methods-added-by-has-one-association-force-reload-false"><code>association(force_reload = false)</code></h5>

<p>如果关联的对象存在，<code>association</code> 方法会返回关联对象。如果找不到关联对象，则返回 <code>nil</code>。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@account</span> <span class="o">=</span> <span class="vi">@supplier</span><span class="p">.</span><span class="nf">account</span>
</pre>

</div>
<p>如果关联对象之前已经取回，会返回缓存版本。如果不想使用缓存版本，强制重新从数据库中读取，可以把 <code>force_reload</code> 参数设为 <code>true</code>。</p>

<h5 id="methods-added-by-has-one-association-associate"><code>association=(associate)</code></h5>

<p><code>association=</code> 方法用来赋值关联的对象。这个方法的底层操作是，从关联对象上读取主键，然后把值赋给该主键对应的关联对象。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@supplier</span><span class="p">.</span><span class="nf">account</span> <span class="o">=</span> <span class="vi">@account</span>
</pre>

</div>
<h5 id="methods-added-by-has-one-build-association-attributes"><code>build_association(attributes = {})</code></h5>

<p><code>build_association</code> 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，但关联对象不会存入数据库。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@account</span> <span class="o">=</span> <span class="vi">@supplier</span><span class="p">.</span><span class="nf">build_account</span><span class="p">(</span><span class="ss">terms: </span><span class="s2">"Net 30"</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-has-one-create-association-attributes"><code>create_association(attributes = {})</code></h5>

<p><code>create_association</code> 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，只要能通过所有数据验证，就会把关联对象存入数据库。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@account</span> <span class="o">=</span> <span class="vi">@supplier</span><span class="p">.</span><span class="nf">create_account</span><span class="p">(</span><span class="ss">terms: </span><span class="s2">"Net 30"</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-has-one-create-association-bang-attributes"><code>create_association!(attributes = {})</code></h5>

<p>和 <code>create_association</code> 方法作用相同，但是如果记录不合法，会抛出 <code>ActiveRecord::RecordInvalid</code> 异常。</p>

<h4 id="options-for-has-one"><code>has_one</code> 方法的选项</h4>

<p>Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 <code>has_one</code> 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Billing"</span><span class="p">,</span> <span class="ss">dependent: :nullify</span>
<span class="k">end</span>
</pre>

</div>
<p><code>has_one</code> 关联支持以下选项：</p>

<ul>
  <li><code>:as</code></li>
  <li><code>:autosave</code></li>
  <li><code>:class_name</code></li>
  <li><code>:dependent</code></li>
  <li><code>:foreign_key</code></li>
  <li><code>:inverse_of</code></li>
  <li><code>:primary_key</code></li>
  <li><code>:source</code></li>
  <li><code>:source_type</code></li>
  <li><code>:through</code></li>
  <li><code>:validate</code></li>
</ul>

<h5 id="options-for-has-one-as"><code>:as</code></h5>

<p><code>:as</code> 选项表明这是多态关联。<a href="#polymorphic-associations">前文</a>已经详细介绍过多态关联。</p>

<h5 id="options-for-has-one-autosave"><code>:autosave</code></h5>

<p>如果把 <code>:autosave</code> 选项设为 <code>true</code>，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。</p>

<h5 id="options-for-has-one-class-name"><code>:class_name</code></h5>

<p>如果另一个模型无法从关联的名字获取，可以使用 <code>:class_name</code> 选项指定模型名。例如，供应商有一个账户，但表示账户的模型是 <code>Billing</code>，就可以这样声明关联：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Billing"</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="options-for-has-one-dependent"><code>:dependent</code></h5>

<p>设置销毁拥有者时要怎么处理关联对象：</p>

<ul>
  <li><code>:destroy</code>：也销毁关联对象；</li>
  <li><code>:delete</code>：直接把关联对象对数据库中删除，因此不会执行回调；</li>
  <li><code>:nullify</code>：把外键设为 <code>NULL</code>，不会执行回调；</li>
  <li><code>:restrict_with_exception</code>：有关联的对象时抛出异常；</li>
  <li><code>:restrict_with_error</code>：有关联的对象时，向拥有者添加一个错误；</li>
</ul>

<p>如果在数据库层设置了 <code>NOT NULL</code> 约束，就不能使用 <code>:nullify</code> 选项。如果 <code>:dependent</code> 选项没有销毁关联，就无法修改关联对象，因为关联对象的外键设置为不接受 <code>NULL</code>。</p>

<h5 id="options-for-has-one-foreign-key"><code>:foreign_key</code></h5>

<p>按照约定，在另一个模型中用来存储外键的字段名是模型名后加 <code>_id</code>。<code>:foreign_key</code> 选项可以设置要使用的外键名：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"supp_id"</span>
<span class="k">end</span>
</pre>

</div>
          <div class="box tip-box">
  <p>不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。</p>
</div>


<h5 id="options-for-has-one-inverse-of"><code>:inverse_of</code></h5>

<p><code>:inverse_of</code> 选项指定 <code>has_one</code> 关联另一端的 <code>belongs_to</code> 关联名。不能和 <code>:through</code> 或 <code>:as</code> 选项一起使用。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span><span class="p">,</span> <span class="ss">inverse_of: :supplier</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:supplier</span><span class="p">,</span> <span class="ss">inverse_of: :account</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="options-for-has-one-primary-key"><code>:primary_key</code></h5>

<p>按照约定，用来存储该模型主键的字段名 <code>id</code>。<code>:primary_key</code> 选项可以设置要使用的主键名。</p>

<h5 id="options-for-has-one-source"><code>:source</code></h5>

<p><code>:source</code> 选项指定 <code>has_one :through</code> 关联的关联源名字。</p>

<h5 id="options-for-has-one-source-type"><code>:source_type</code></h5>

<p><code>:source_type</code> 选项指定 <code>has_one :through</code> 关联中用来处理多态关联的关联源类型。</p>

<h5 id="options-for-has-one-through"><code>:through</code></h5>

<p><code>:through</code> 选项指定用来执行查询的连接模型。<a href="#the-has-one-through-association">前文</a>详细介绍过 <code>has_one :through</code> 关联。</p>

<h5 id="options-for-has-one-validate"><code>:validate</code></h5>

<p>如果把 <code>:validate</code> 选项设为 <code>true</code>，保存对象时，会同时验证关联对象。该选项的默认值是 <code>false</code>，保存对象时不验证关联对象。</p>

<h4 id="scopes-for-has-one"><code>has_one</code> 的作用域</h4>

<p>有时可能需要定制 <code>has_one</code> 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">active: </span><span class="kp">true</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<p>在作用域代码块中可以使用任何一个标准的<a href="http://docs-china.com/rails/active_record_querying.html">查询方法</a>。下面分别介绍这几个方法：</p>

<ul>
  <li><code>where</code></li>
  <li><code>includes</code></li>
  <li><code>readonly</code></li>
  <li><code>select</code></li>
</ul>

<h5 id="scopes-for-has-one-where"><code>where</code></h5>

<p><code>where</code> 方法指定关联对象必须满足的条件。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s2">"confirmed = 1"</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-one-includes"><code>includes</code></h5>

<p><code>includes</code> 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:supplier</span>
  <span class="n">belongs_to</span> <span class="ss">:representative</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Representative</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:accounts</span>
<span class="k">end</span>
</pre>

</div>
<p>如果经常要直接获取供应商代表（<code>@supplier.account.representative</code>），就可以把代表引入供应商和账户的关联中：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_one</span> <span class="ss">:account</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">includes</span> <span class="ss">:representative</span> <span class="p">}</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Account</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:supplier</span>
  <span class="n">belongs_to</span> <span class="ss">:representative</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Representative</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:accounts</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-one-readonly"><code>readonly</code></h5>

<p>如果使用 <code>readonly</code>，通过关联获取的对象就是只读的。</p>

<h5 id="scopes-for-has-one-select"><code>select</code></h5>

<p><code>select</code> 方法会覆盖获取关联对象使用的 SQL <code>SELECT</code> 子句。默认情况下，Rails 会读取所有字段。</p>

<h4 id="has-one-association-reference-do-any-associated-objects-exist-questionmark">检查关联的对象是否存在</h4>

<p>检查关联的对象是否存在可以使用 <code>association.nil?</code> 方法：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">if</span> <span class="vi">@supplier</span><span class="p">.</span><span class="nf">account</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="vi">@msg</span> <span class="o">=</span> <span class="s2">"No account found for this supplier"</span>
<span class="k">end</span>
</pre>

</div>
<h4 id="has-one-association-reference-when-are-objects-saved-questionmark">什么时候保存对象</h4>

<p>把对象赋值给 <code>has_one</code> 关联时，会自动保存对象（因为要更新外键）。而且所有被替换的对象也会自动保存，因为外键也变了。</p>

<p>如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 <code>false</code>，赋值操作会取消。</p>

<p>如果父对象（<code>has_one</code> 关联声明所在的模型）没保存（<code>new_record?</code> 方法返回 <code>true</code>），那么子对象也不会保存。只有保存了父对象，才会保存子对象。</p>

<p>如果赋值给 <code>has_one</code> 关联时不想保存对象，可以使用 <code>association.build</code> 方法。</p>

<h3 id="has-many-association-reference"><code>has_many</code> 关联详解</h3>

<p><code>has_many</code> 关联建立两个模型之间的一对多关系。用数据库的行话说，这种关联的意思是外键在另一个类中，指向这个类的实例。</p>

<h4 id="methods-added-by-has-many"><code>has_many</code> 关联添加的方法</h4>

<p>声明 <code>has_many</code> 关联后，声明所在的类自动获得了 16 个关联相关的方法：</p>

<ul>
  <li><code>collection(force_reload = false)</code></li>
  <li><code>collection&lt;&lt;(object, ...)</code></li>
  <li><code>collection.delete(object, ...)</code></li>
  <li><code>collection.destroy(object, ...)</code></li>
  <li><code>collection=objects</code></li>
  <li><code>collection_singular_ids</code></li>
  <li><code>collection_singular_ids=ids</code></li>
  <li><code>collection.clear</code></li>
  <li><code>collection.empty?</code></li>
  <li><code>collection.size</code></li>
  <li><code>collection.find(...)</code></li>
  <li><code>collection.where(...)</code></li>
  <li><code>collection.exists?(...)</code></li>
  <li><code>collection.build(attributes = {}, ...)</code></li>
  <li><code>collection.create(attributes = {})</code></li>
  <li><code>collection.create!(attributes = {})</code></li>
</ul>

<p>这些个方法中的 <code>collection</code> 要替换成传入 <code>has_many</code> 方法的第一个参数。<code>collection_singular</code> 要替换成第一个参数的单数形式。例如，如下的声明：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>
</pre>

</div>
<p>每个 <code>Customer</code> 模型实例都获得了这些方法：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">orders</span><span class="p">(</span><span class="n">force_reload</span> <span class="o">=</span> <span class="kp">false</span><span class="p">)</span>
<span class="n">orders</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">destroy</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">orders</span><span class="o">=</span><span class="n">objects</span>
<span class="n">order_ids</span>
<span class="n">order_ids</span><span class="o">=</span><span class="n">ids</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">clear</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">empty?</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">size</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">find</span><span class="p">(.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">where</span><span class="p">(.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
<span class="n">orders</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-force-reload-false"><code>collection(force_reload = false)</code></h5>

<p><code>collection</code> 方法返回一个数组，包含所有关联的对象。如果没有关联的对象，则返回空数组。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@orders</span> <span class="o">=</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-object"><code>collection&lt;&lt;(object, ...)</code></h5>

<p><code>collection&lt;&lt;</code> 方法向关联对象数组中添加一个或多个对象，并把各所加对象的外键设为调用此方法的模型的主键。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span> <span class="o">&lt;&lt;</span> <span class="vi">@order1</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-delete-object"><code>collection.delete(object, ...)</code></h5>

<p><code>collection.delete</code> 方法从关联对象数组中删除一个或多个对象，并把删除的对象外键设为 <code>NULL</code>。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="vi">@order1</span><span class="p">)</span>
</pre>

</div>
          <div class="box warning-box">
  <p>如果关联设置了 <code>dependent: :destroy</code>，还会销毁关联对象；如果关联设置了 <code>dependent: :delete_all</code>，还会删除关联对象。</p>
</div>


<h5 id="methods-added-by-has-many-collection-destroy-object"><code>collection.destroy(object, ...)</code></h5>

<p><code>collection.destroy</code> 方法在关联对象上调用 <code>destroy</code> 方法，从关联对象数组中删除一个或多个对象。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">destroy</span><span class="p">(</span><span class="vi">@order1</span><span class="p">)</span>
</pre>

</div>
          <div class="box warning-box">
  <p>对象会从数据库中删除，忽略 <code>:dependent</code> 选项。</p>
</div>


<h5 id="methods-added-by-has-many-collection-objects"><code>collection=objects</code></h5>

<p><code>collection=</code> 让关联对象数组只包含指定的对象，根据需求会添加或删除对象。</p>

<h5 id="methods-added-by-has-many-collection-singular-ids"><code>collection_singular_ids</code></h5>

<p><code>collection_singular_ids</code> 返回一个数组，包含关联对象数组中各对象的 ID。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@order_ids</span> <span class="o">=</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">order_ids</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-singular-ids-ids"><code>collection_singular_ids=ids</code></h5>

<p><code>collection_singular_ids=</code> 方法让数组中只包含指定的主键，根据需要增删 ID。</p>

<h5 id="methods-added-by-has-many-collection-clear"><code>collection.clear</code></h5>

<p><code>collection.clear</code> 方法删除数组中的所有对象。如果关联中指定了 <code>dependent: :destroy</code> 选项，会销毁关联对象；如果关联中指定了 <code>dependent: :delete_all</code> 选项，会直接从数据库中删除对象，然后再把外键设为 <code>NULL</code>。</p>

<h5 id="methods-added-by-has-many-collection-empty-questionmark"><code>collection.empty?</code></h5>

<p>如果关联数组中没有关联对象，<code>collection.empty?</code> 方法返回 <code>true</code>。</p>

<div class="codeblock erb"><pre class="highlight"><span class="cp">&lt;%</span> <span class="k">if</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">empty?</span> <span class="cp">%&gt;</span>
  No Orders Found
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-size"><code>collection.size</code></h5>

<p><code>collection.size</code> 返回关联对象数组中的对象数量。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@order_count</span> <span class="o">=</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">size</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-find"><code>collection.find(...)</code></h5>

<p><code>collection.find</code> 方法在关联对象数组中查找对象，句法和可用选项跟 <code>ActiveRecord::Base.find</code> 方法一样。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@open_orders</span> <span class="o">=</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-where"><code>collection.where(...)</code></h5>

<p><code>collection.where</code> 方法根据指定的条件在关联对象数组中查找对象，但会惰性加载对象，用到对象时才会执行查询。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@open_orders</span> <span class="o">=</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="nb">open</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span> <span class="c1"># No query yet</span>
<span class="vi">@open_order</span> <span class="o">=</span> <span class="vi">@open_orders</span><span class="p">.</span><span class="nf">first</span> <span class="c1"># Now the database will be queried</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-exists-questionmark"><code>collection.exists?(...)</code></h5>

<p><code>collection.exists?</code> 方法根据指定的条件检查关联对象数组中是否有符合条件的对象，句法和可用选项跟 <code>ActiveRecord::Base.exists?</code> 方法一样。</p>

<h5 id="methods-added-by-has-many-collection-build-attributes"><code>collection.build(attributes = {}, ...)</code></h5>

<p><code>collection.build</code> 方法返回一个或多个此种关联类型的新对象。这些对象会使用传入的属性初始化，还会创建对应的外键，但不会保存关联对象。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@order</span> <span class="o">=</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="ss">order_date: </span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">,</span>
                                <span class="ss">order_number: </span><span class="s2">"A12345"</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-create-attributes"><code>collection.create(attributes = {})</code></h5>

<p><code>collection.create</code> 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会创建对应的外键，只要能通过所有数据验证，就会保存关联对象。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@order</span> <span class="o">=</span> <span class="vi">@customer</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">order_date: </span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">,</span>
                                 <span class="ss">order_number: </span><span class="s2">"A12345"</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-has-many-collection-create-bang-attributes"><code>collection.create!(attributes = {})</code></h5>

<p>作用和 <code>collection.create</code> 相同，但如果记录不合法会抛出 <code>ActiveRecord::RecordInvalid</code> 异常。</p>

<h4 id="options-for-has-many"><code>has_many</code> 方法的选项</h4>

<p>Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 <code>has_many</code> 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">dependent: :delete_all</span><span class="p">,</span> <span class="ss">validate: :false</span>
<span class="k">end</span>
</pre>

</div>
<p><code>has_many</code> 关联支持以下选项：</p>

<ul>
  <li><code>:as</code></li>
  <li><code>:autosave</code></li>
  <li><code>:class_name</code></li>
  <li><code>:dependent</code></li>
  <li><code>:foreign_key</code></li>
  <li><code>:inverse_of</code></li>
  <li><code>:primary_key</code></li>
  <li><code>:source</code></li>
  <li><code>:source_type</code></li>
  <li><code>:through</code></li>
  <li><code>:validate</code></li>
</ul>

<h5 id="options-for-has-many-as"><code>:as</code></h5>

<p><code>:as</code> 选项表明这是多态关联。<a href="#polymorphic-associations">前文</a>已经详细介绍过多态关联。</p>

<h5 id="options-for-has-many-autosave"><code>:autosave</code></h5>

<p>如果把 <code>:autosave</code> 选项设为 <code>true</code>，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。</p>

<h5 id="options-for-has-many-class-name"><code>:class_name</code></h5>

<p>如果另一个模型无法从关联的名字获取，可以使用 <code>:class_name</code> 选项指定模型名。例如，顾客有多个订单，但表示订单的模型是 <code>Transaction</code>，就可以这样声明关联：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Transaction"</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="dependent"><code>:dependent</code></h5>

<p>设置销毁拥有者时要怎么处理关联对象：</p>

<ul>
  <li><code>:destroy</code>：也销毁所有关联的对象；</li>
  <li><code>:delete_all</code>：直接把所有关联对象对数据库中删除，因此不会执行回调；</li>
  <li><code>:nullify</code>：把外键设为 <code>NULL</code>，不会执行回调；</li>
  <li><code>:restrict_with_exception</code>：有关联的对象时抛出异常；</li>
  <li><code>:restrict_with_error</code>：有关联的对象时，向拥有者添加一个错误；</li>
</ul>

          <div class="box information-box">
  <p>如果声明关联时指定了 <code>:through</code> 选项，会忽略这个选项。</p>
</div>


<h5 id="options-for-has-many-foreign-key"><code>:foreign_key</code></h5>

<p>按照约定，另一个模型中用来存储外键的字段名是模型名后加 <code>_id</code>。<code>:foreign_key</code> 选项可以设置要使用的外键名：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"cust_id"</span>
<span class="k">end</span>
</pre>

</div>
          <div class="box tip-box">
  <p>不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。</p>
</div>


<h5 id="inverse-of"><code>:inverse_of</code></h5>

<p><code>:inverse_of</code> 选项指定 <code>has_many</code> 关联另一端的 <code>belongs_to</code> 关联名。不能和 <code>:through</code> 或 <code>:as</code> 选项一起使用。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">inverse_of: :customer</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">inverse_of: :orders</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="options-for-has-many-primary-key"><code>:primary_key</code></h5>

<p>按照约定，用来存储该模型主键的字段名 <code>id</code>。<code>:primary_key</code> 选项可以设置要使用的主键名。</p>

<p>假设 <code>users</code> 表的主键是 <code>id</code>，但还有一个 <code>guid</code> 字段。根据要求，<code>todos</code> 表中应该使用 <code>guid</code> 字段，而不是 <code>id</code> 字段。这种需求可以这么实现：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:todos</span><span class="p">,</span> <span class="ss">primary_key: :guid</span>
<span class="k">end</span>
</pre>

</div>
<p>如果执行 <code>@user.todos.create</code> 创建新的待办事项，那么 <code>@todo.user_id</code> 就是 <code>guid</code> 字段中的值。</p>

<h5 id="options-for-has-many-source"><code>:source</code></h5>

<p><code>:source</code> 选项指定 <code>has_many :through</code> 关联的关联源名字。只有无法从关联名种解出关联源的名字时才需要设置这个选项。</p>

<h5 id="options-for-has-many-source-type"><code>:source_type</code></h5>

<p><code>:source_type</code> 选项指定 <code>has_many :through</code> 关联中用来处理多态关联的关联源类型。</p>

<h5 id="options-for-has-many-through"><code>:through</code></h5>

<p><code>:through</code> 选项指定用来执行查询的连接模型。<code>has_many :through</code> 关联是实现多对多关联的一种方式，<a href="#the-has-many-through-association">前文</a>已经介绍过。</p>

<h5 id="options-for-has-many-validate"><code>:validate</code></h5>

<p>如果把 <code>:validate</code> 选项设为 <code>false</code>，保存对象时，不会验证关联对象。该选项的默认值是 <code>true</code>，保存对象验证关联的对象。</p>

<h4 id="scopes-for-has-many"><code>has_many</code> 的作用域</h4>

<p>有时可能需要定制 <code>has_many</code> 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">processed: </span><span class="kp">true</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<p>在作用域代码块中可以使用任何一个标准的<a href="http://docs-china.com/rails/active_record_querying.html">查询方法</a>。下面分别介绍这几个方法：</p>

<ul>
  <li><code>where</code></li>
  <li><code>extending</code></li>
  <li><code>group</code></li>
  <li><code>includes</code></li>
  <li><code>limit</code></li>
  <li><code>offset</code></li>
  <li><code>order</code></li>
  <li><code>readonly</code></li>
  <li><code>select</code></li>
  <li><code>uniq</code></li>
</ul>

<h5 id="scopes-for-has-many-where"><code>where</code></h5>

<p><code>where</code> 方法指定关联对象必须满足的条件。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:confirmed_orders</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s2">"confirmed = 1"</span> <span class="p">},</span>
    <span class="ss">class_name: </span><span class="s2">"Order"</span>
<span class="k">end</span>
</pre>

</div>
<p>条件还可以使用 Hash 的形式指定：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:confirmed_orders</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">confirmed: </span><span class="kp">true</span> <span class="p">},</span>
                              <span class="ss">class_name: </span><span class="s2">"Order"</span>
<span class="k">end</span>
</pre>

</div>
<p>如果 <code>where</code> 使用 Hash 形式，通过这个关联创建的记录会自动使用 Hash 中的作用域。针对上面的例子，使用 <code>@customer.confirmed_orders.create</code> 或 <code>@customer.confirmed_orders.build</code> 创建订单时，会自动把 <code>confirmed</code> 字段的值设为 <code>true</code>。</p>

<h5 id="scopes-for-has-many-extending"><code>extending</code></h5>

<p><code>extending</code> 方法指定一个模块名，用来扩展关联代理。<a href="#association-extensions">后文</a>会详细介绍关联扩展。</p>

<h5 id="scopes-for-has-many-group"><code>group</code></h5>

<p><code>group</code> 方法指定一个属性名，用在 SQL <code>GROUP BY</code> 子句中，分组查询结果。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:line_items</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">group</span> <span class="s1">'orders.id'</span> <span class="p">},</span>
                        <span class="ss">through: :orders</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-many-includes"><code>includes</code></h5>

<p><code>includes</code> 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">has_many</span> <span class="ss">:line_items</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">LineItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:order</span>
<span class="k">end</span>
</pre>

</div>
<p>如果经常要直接获取顾客购买的商品（<code>@customer.orders.line_items</code>），就可以把商品引入顾客和订单的关联中：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">includes</span> <span class="ss">:line_items</span> <span class="p">}</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">has_many</span> <span class="ss">:line_items</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">LineItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:order</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-many-limit"><code>limit</code></h5>

<p><code>limit</code> 方法限制通过关联获取的对象数量。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:recent_orders</span><span class="p">,</span>
    <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="s1">'order_date desc'</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">},</span>
    <span class="ss">class_name: </span><span class="s2">"Order"</span><span class="p">,</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-many-offset"><code>offset</code></h5>

<p><code>offset</code> 方法指定通过关联获取对象时的偏移量。例如，<code>-&gt; { offset(11) }</code> 会跳过前 11 个记录。</p>

<h5 id="scopes-for-has-many-order"><code>order</code></h5>

<p><code>order</code> 方法指定获取关联对象时使用的排序方式，用于 SQL <code>ORDER BY</code> 子句。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span> <span class="s2">"date_confirmed DESC"</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-many-readonly"><code>readonly</code></h5>

<p>如果使用 <code>readonly</code>，通过关联获取的对象就是只读的。</p>

<h5 id="scopes-for-has-many-select"><code>select</code></h5>

<p><code>select</code> 方法用来覆盖获取关联对象数据的 SQL <code>SELECT</code> 子句。默认情况下，Rails 会读取所有字段。</p>

          <div class="box warning-box">
  <p>如果设置了 <code>select</code>，记得要包含主键和关联模型的外键。否则，Rails 会抛出异常。</p>
</div>


<h5><code>distinct</code></h5>

<p>使用 <code>distinct</code> 方法可以确保集合中没有重复的对象，和 <code>:through</code> 选项一起使用最有用。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Person</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:readings</span>
  <span class="n">has_many</span> <span class="ss">:posts</span><span class="p">,</span> <span class="ss">through: :readings</span>
<span class="k">end</span>

<span class="n">person</span> <span class="o">=</span> <span class="no">Person</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s1">'John'</span><span class="p">)</span>
<span class="n">post</span>   <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s1">'a1'</span><span class="p">)</span>
<span class="n">person</span><span class="p">.</span><span class="nf">posts</span> <span class="o">&lt;&lt;</span> <span class="n">post</span>
<span class="n">person</span><span class="p">.</span><span class="nf">posts</span> <span class="o">&lt;&lt;</span> <span class="n">post</span>
<span class="n">person</span><span class="p">.</span><span class="nf">posts</span><span class="p">.</span><span class="nf">inspect</span> <span class="c1"># =&gt; [#&lt;Post id: 5, name: "a1"&gt;, #&lt;Post id: 5, name: "a1"&gt;]</span>
<span class="no">Reading</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">inspect</span>  <span class="c1"># =&gt; [#&lt;Reading id: 12, person_id: 5, post_id: 5&gt;, #&lt;Reading id: 13, person_id: 5, post_id: 5&gt;]</span>
</pre>

</div>
<p>在上面的代码中，读者读了两篇文章，即使是同一篇文章，<code>person.posts</code> 也会返回两个对象。</p>

<p>下面我们加入 <code>distinct</code> 方法：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Person</span>
  <span class="n">has_many</span> <span class="ss">:readings</span>
  <span class="n">has_many</span> <span class="ss">:posts</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">distinct</span> <span class="p">},</span> <span class="ss">through: :readings</span>
<span class="k">end</span>

<span class="n">person</span> <span class="o">=</span> <span class="no">Person</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s1">'Honda'</span><span class="p">)</span>
<span class="n">post</span>   <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s1">'a1'</span><span class="p">)</span>
<span class="n">person</span><span class="p">.</span><span class="nf">posts</span> <span class="o">&lt;&lt;</span> <span class="n">post</span>
<span class="n">person</span><span class="p">.</span><span class="nf">posts</span> <span class="o">&lt;&lt;</span> <span class="n">post</span>
<span class="n">person</span><span class="p">.</span><span class="nf">posts</span><span class="p">.</span><span class="nf">inspect</span> <span class="c1"># =&gt; [#&lt;Post id: 7, name: "a1"&gt;]</span>
<span class="no">Reading</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">inspect</span>  <span class="c1"># =&gt; [#&lt;Reading id: 16, person_id: 7, post_id: 7&gt;, #&lt;Reading id: 17, person_id: 7, post_id: 7&gt;]</span>
</pre>

</div>
<p>在这段代码中，读者还是读了两篇文章，但 <code>person.posts</code> 只返回一个对象，因为加载的集合已经去除了重复元素。</p>

<p>如果要确保只把不重复的记录写入关联模型的数据表（这样就不会从数据库中获取重复记录了），需要在数据表上添加唯一性索引。例如，数据表名为 <code>person_posts</code>，我们要保证其中所有的文章都没重复，可以在迁移中加入以下代码：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">add_index</span> <span class="ss">:person_posts</span><span class="p">,</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
</pre>

</div>
<p>注意，使用 <code>include?</code> 等方法检查唯一性可能导致条件竞争。不要使用 <code>include?</code> 确保关联的唯一性。还是以前面的文章模型为例，下面的代码会导致条件竞争，因为多个用户可能会同时执行这一操作：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">person</span><span class="p">.</span><span class="nf">posts</span> <span class="o">&lt;&lt;</span> <span class="n">post</span> <span class="k">unless</span> <span class="n">person</span><span class="p">.</span><span class="nf">posts</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
</pre>

</div>
<h4 id="has-many-association-reference-when-are-objects-saved-questionmark">什么时候保存对象</h4>

<p>把对象赋值给 <code>has_many</code> 关联时，会自动保存对象（因为要更新外键）。如果一次赋值多个对象，所有对象都会自动保存。</p>

<p>如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 <code>false</code>，赋值操作会取消。</p>

<p>如果父对象（<code>has_many</code> 关联声明所在的模型）没保存（<code>new_record?</code> 方法返回 <code>true</code>），那么子对象也不会保存。只有保存了父对象，才会保存子对象。</p>

<p>如果赋值给 <code>has_many</code> 关联时不想保存对象，可以使用 <code>collection.build</code> 方法。</p>

<h3 id="has-and-belongs-to-many-association-reference"><code>has_and_belongs_to_many</code> 关联详解</h3>

<p><code>has_and_belongs_to_many</code> 关联建立两个模型之间的多对多关系。用数据库的行话说，这种关联的意思是有个连接数据表包含指向这两个类的外键。</p>

<h4 id="methods-added-by-has-and-belongs-to-many"><code>has_and_belongs_to_many</code> 关联添加的方法</h4>

<p>声明 <code>has_and_belongs_to_many</code> 关联后，声明所在的类自动获得了 16 个关联相关的方法：</p>

<ul>
  <li><code>collection(force_reload = false)</code></li>
  <li><code>collection&lt;&lt;(object, ...)</code></li>
  <li><code>collection.delete(object, ...)</code></li>
  <li><code>collection.destroy(object, ...)</code></li>
  <li><code>collection=objects</code></li>
  <li><code>collection_singular_ids</code></li>
  <li><code>collection_singular_ids=ids</code></li>
  <li><code>collection.clear</code></li>
  <li><code>collection.empty?</code></li>
  <li><code>collection.size</code></li>
  <li><code>collection.find(...)</code></li>
  <li><code>collection.where(...)</code></li>
  <li><code>collection.exists?(...)</code></li>
  <li><code>collection.build(attributes = {})</code></li>
  <li><code>collection.create(attributes = {})</code></li>
  <li><code>collection.create!(attributes = {})</code></li>
</ul>

<p>这些个方法中的 <code>collection</code> 要替换成传入 <code>has_and_belongs_to_many</code> 方法的第一个参数。<code>collection_singular</code> 要替换成第一个参数的单数形式。例如，如下的声明：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Part</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span>
<span class="k">end</span>
</pre>

</div>
<p>每个 <code>Part</code> 模型实例都获得了这些方法：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="n">assemblies</span><span class="p">(</span><span class="n">force_reload</span> <span class="o">=</span> <span class="kp">false</span><span class="p">)</span>
<span class="n">assemblies</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">destroy</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">assemblies</span><span class="o">=</span><span class="n">objects</span>
<span class="n">assembly_ids</span>
<span class="n">assembly_ids</span><span class="o">=</span><span class="n">ids</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">clear</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">empty?</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">size</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">find</span><span class="p">(.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">where</span><span class="p">(.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">)</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
<span class="n">assemblies</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
</pre>

</div>
<h5 id="additional-column-methods">额外的字段方法</h5>

<p>如果 <code>has_and_belongs_to_many</code> 关联使用的连接数据表中，除了两个外键之外还有其他字段，通过关联获取的记录中会包含这些字段，但是只读字段，因为 Rails 不知道如何保存对这些字段的改动。</p>

          <div class="box warning-box">
  <p>在 <code>has_and_belongs_to_many</code> 关联的连接数据表中使用其他字段的功能已经废弃。如果在多对多关联中需要使用这么复杂的数据表，可以用 <code>has_many :through</code> 关联代替 <code>has_and_belongs_to_many</code> 关联。</p>
</div>


<h5 id="methods-added-by-has-and-belongs-to-many-collection-force-reload-false"><code>collection(force_reload = false)</code></h5>

<p><code>collection</code> 方法返回一个数组，包含所有关联的对象。如果没有关联的对象，则返回空数组。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@assemblies</span> <span class="o">=</span> <span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-object"><code>collection&lt;&lt;(object, ...)</code></h5>

<p><code>collection&lt;&lt;</code> 方法向关联对象数组中添加一个或多个对象，并在连接数据表中创建相应的记录。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span> <span class="o">&lt;&lt;</span> <span class="vi">@assembly1</span>
</pre>

</div>
          <div class="box information-box">
  <p>这个方法与 <code>collection.concat</code> 和 <code>collection.push</code> 是同名方法。</p>
</div>


<h5 id="methods-added-by-has-and-belongs-to-many-collection-delete-object"><code>collection.delete(object, ...)</code></h5>

<p><code>collection.delete</code> 方法从关联对象数组中删除一个或多个对象，并删除连接数据表中相应的记录。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="vi">@assembly1</span><span class="p">)</span>
</pre>

</div>
          <div class="box warning-box">
  <p>这个方法不会触发连接记录上的回调。</p>
</div>


<h5 id="methods-added-by-has-and-belongs-to-many-collection-destroy-object"><code>collection.destroy(object, ...)</code></h5>

<p><code>collection.destroy</code> 方法在连接数据表中的记录上调用 <code>destroy</code> 方法，从关联对象数组中删除一个或多个对象，还会触发回调。这个方法不会销毁对象本身。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span><span class="p">.</span><span class="nf">destroy</span><span class="p">(</span><span class="vi">@assembly1</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-objects"><code>collection=objects</code></h5>

<p><code>collection=</code> 让关联对象数组只包含指定的对象，根据需求会添加或删除对象。</p>

<h5 id="methods-added-by-has-and-belongs-to-many-collection-singular-ids"><code>collection_singular_ids</code></h5>

<p><code>collection_singular_ids</code> 返回一个数组，包含关联对象数组中各对象的 ID。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@assembly_ids</span> <span class="o">=</span> <span class="vi">@part</span><span class="p">.</span><span class="nf">assembly_ids</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-singular-ids-ids"><code>collection_singular_ids=ids</code></h5>

<p><code>collection_singular_ids=</code> 方法让数组中只包含指定的主键，根据需要增删 ID。</p>

<h5 id="methods-added-by-has-and-belongs-to-many-collection-clear"><code>collection.clear</code></h5>

<p><code>collection.clear</code> 方法删除数组中的所有对象，并把连接数据表中的相应记录删除。这个方法不会销毁关联对象。</p>

<h5 id="methods-added-by-has-and-belongs-to-many-collection-empty-questionmark"><code>collection.empty?</code></h5>

<p>如果关联数组中没有关联对象，<code>collection.empty?</code> 方法返回 <code>true</code>。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="o">&lt;</span><span class="sx">% if </span><span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span><span class="p">.</span><span class="nf">empty?</span> <span class="sx">%&gt;
  This part is not used in any assemblies
&lt;% end %&gt;</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-size"><code>collection.size</code></h5>

<p><code>collection.size</code> 返回关联对象数组中的对象数量。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@assembly_count</span> <span class="o">=</span> <span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span><span class="p">.</span><span class="nf">size</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-find"><code>collection.find(...)</code></h5>

<p><code>collection.find</code> 方法在关联对象数组中查找对象，句法和可用选项跟 <code>ActiveRecord::Base.find</code> 方法一样。同时还限制对象必须在集合中。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@assembly</span> <span class="o">=</span> <span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-where"><code>collection.where(...)</code></h5>

<p><code>collection.where</code> 方法根据指定的条件在关联对象数组中查找对象，但会惰性加载对象，用到对象时才会执行查询。同时还限制对象必须在集合中。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@new_assemblies</span> <span class="o">=</span> <span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt; ?"</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="nf">days</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-exists-questionmark"><code>collection.exists?(...)</code></h5>

<p><code>collection.exists?</code> 方法根据指定的条件检查关联对象数组中是否有符合条件的对象，句法和可用选项跟 <code>ActiveRecord::Base.exists?</code> 方法一样。</p>

<h5 id="methods-added-by-has-and-belongs-to-many-collection-build-attributes"><code>collection.build(attributes = {})</code></h5>

<p><code>collection.build</code> 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会在连接数据表中创建对应的记录，但不会保存关联对象。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@assembly</span> <span class="o">=</span> <span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span><span class="p">.</span><span class="nf">build</span><span class="p">({</span><span class="ss">assembly_name: </span><span class="s2">"Transmission housing"</span><span class="p">})</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-create-attributes"><code>collection.create(attributes = {})</code></h5>

<p><code>collection.create</code> 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会在连接数据表中创建对应的记录，只要能通过所有数据验证，就会保存关联对象。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="vi">@assembly</span> <span class="o">=</span> <span class="vi">@part</span><span class="p">.</span><span class="nf">assemblies</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span><span class="ss">assembly_name: </span><span class="s2">"Transmission housing"</span><span class="p">})</span>
</pre>

</div>
<h5 id="methods-added-by-has-and-belongs-to-many-collection-create-bang-attributes"><code>collection.create!(attributes = {})</code></h5>

<p>作用和 <code>collection.create</code> 相同，但如果记录不合法会抛出 <code>ActiveRecord::RecordInvalid</code> 异常。</p>

<h4 id="options-for-has-and-belongs-to-many"><code>has_and_belongs_to_many</code> 方法的选项</h4>

<p>Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 <code>has_and_belongs_to_many</code> 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Parts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span><span class="p">,</span> <span class="ss">autosave: </span><span class="kp">true</span><span class="p">,</span>
                                       <span class="ss">readonly: </span><span class="kp">true</span>
<span class="k">end</span>
</pre>

</div>
<p><code>has_and_belongs_to_many</code> 关联支持以下选项：</p>

<ul>
  <li><code>:association_foreign_key</code></li>
  <li><code>:autosave</code></li>
  <li><code>:class_name</code></li>
  <li><code>:foreign_key</code></li>
  <li><code>:join_table</code></li>
  <li><code>:validate</code></li>
  <li><code>:readonly</code></li>
</ul>

<h5 id="association-foreign-key"><code>:association_foreign_key</code></h5>

<p>按照约定，在连接数据表中用来指向另一个模型的外键名是模型名后加 <code>_id</code>。<code>:association_foreign_key</code> 选项可以设置要使用的外键名：</p>

          <div class="box tip-box">
  <p><code>:foreign_key</code> 和 <code>:association_foreign_key</code> 这两个选项在设置多对多自连接时很有用。</p>
</div>


<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:friends</span><span class="p">,</span>
      <span class="ss">class_name: </span><span class="s2">"User"</span><span class="p">,</span>
      <span class="ss">foreign_key: </span><span class="s2">"this_user_id"</span><span class="p">,</span>
      <span class="ss">association_foreign_key: </span><span class="s2">"other_user_id"</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="options-for-has-and-belongs-to-many-autosave"><code>:autosave</code></h5>

<p>如果把 <code>:autosave</code> 选项设为 <code>true</code>，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。</p>

<h5 id="options-for-has-and-belongs-to-many-class-name"><code>:class_name</code></h5>

<p>如果另一个模型无法从关联的名字获取，可以使用 <code>:class_name</code> 选项指定模型名。例如，一个部件由多个装配件组成，但表示装配件的模型是 <code>Gadget</code>，就可以这样声明关联：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Parts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Gadget"</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="options-for-has-and-belongs-to-many-foreign-key"><code>:foreign_key</code></h5>

<p>按照约定，在连接数据表中用来指向模型的外键名是模型名后加 <code>_id</code>。<code>:foreign_key</code> 选项可以设置要使用的外键名：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:friends</span><span class="p">,</span>
      <span class="ss">class_name: </span><span class="s2">"User"</span><span class="p">,</span>
      <span class="ss">foreign_key: </span><span class="s2">"this_user_id"</span><span class="p">,</span>
      <span class="ss">association_foreign_key: </span><span class="s2">"other_user_id"</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="join-table"><code>:join_table</code></h5>

<p>如果默认按照字典顺序生成的默认名不能满足要求，可以使用 <code>:join_table</code> 选项指定。</p>

<h5 id="options-for-has-and-belongs-to-many-validate"><code>:validate</code></h5>

<p>如果把 <code>:validate</code> 选项设为 <code>false</code>，保存对象时，不会验证关联对象。该选项的默认值是 <code>true</code>，保存对象验证关联的对象。</p>

<h4 id="scopes-for-has-and-belongs-to-many"><code>has_and_belongs_to_many</code> 的作用域</h4>

<p>有时可能需要定制 <code>has_and_belongs_to_many</code> 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Parts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">active: </span><span class="kp">true</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<p>在作用域代码块中可以使用任何一个标准的<a href="http://docs-china.com/rails/active_record_querying.html">查询方法</a>。下面分别介绍这几个方法：</p>

<ul>
  <li><code>where</code></li>
  <li><code>extending</code></li>
  <li><code>group</code></li>
  <li><code>includes</code></li>
  <li><code>limit</code></li>
  <li><code>offset</code></li>
  <li><code>order</code></li>
  <li><code>readonly</code></li>
  <li><code>select</code></li>
  <li><code>uniq</code></li>
</ul>

<h5 id="scopes-for-has-and-belongs-to-many-where"><code>where</code></h5>

<p><code>where</code> 方法指定关联对象必须满足的条件。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Parts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span><span class="p">,</span>
    <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="s2">"factory = 'Seattle'"</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<p>条件还可以使用 Hash 的形式指定：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Parts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span><span class="p">,</span>
    <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">factory: </span><span class="s1">'Seattle'</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<p>如果 <code>where</code> 使用 Hash 形式，通过这个关联创建的记录会自动使用 Hash 中的作用域。针对上面的例子，使用 <code>@parts.assemblies.create</code> 或 <code>@parts.assemblies.build</code> 创建订单时，会自动把 <code>factory</code> 字段的值设为 <code>"Seattle"</code>。</p>

<h5 id="scopes-for-has-and-belongs-to-many-extending"><code>extending</code></h5>

<p><code>extending</code> 方法指定一个模块名，用来扩展关联代理。<a href="#association-extensions">后文</a>会详细介绍关联扩展。</p>

<h5 id="scopes-for-has-and-belongs-to-many-group"><code>group</code></h5>

<p><code>group</code> 方法指定一个属性名，用在 SQL <code>GROUP BY</code> 子句中，分组查询结果。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Parts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">group</span> <span class="s2">"factory"</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-and-belongs-to-many-includes"><code>includes</code></h5>

<p><code>includes</code> 方法指定使用关联时要按需加载的间接关联。</p>

<h5 id="scopes-for-has-and-belongs-to-many-limit"><code>limit</code></h5>

<p><code>limit</code> 方法限制通过关联获取的对象数量。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Parts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span><span class="p">,</span>
    <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-and-belongs-to-many-offset"><code>offset</code></h5>

<p><code>offset</code> 方法指定通过关联获取对象时的偏移量。例如，<code>-&gt; { offset(11) }</code> 会跳过前 11 个记录。</p>

<h5 id="scopes-for-has-and-belongs-to-many-order"><code>order</code></h5>

<p><code>order</code> 方法指定获取关联对象时使用的排序方式，用于 SQL <code>ORDER BY</code> 子句。</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Parts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:assemblies</span><span class="p">,</span>
    <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span> <span class="s2">"assembly_name ASC"</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<h5 id="scopes-for-has-and-belongs-to-many-readonly"><code>readonly</code></h5>

<p>如果使用 <code>readonly</code>，通过关联获取的对象就是只读的。</p>

<h5 id="scopes-for-has-and-belongs-to-many-select"><code>select</code></h5>

<p><code>select</code> 方法用来覆盖获取关联对象数据的 SQL <code>SELECT</code> 子句。默认情况下，Rails 会读取所有字段。</p>

<h5 id="uniq"><code>uniq</code></h5>

<p><code>uniq</code> 方法用来删除集合中重复的对象。</p>

<h4 id="has-and-belongs-to-many-association-reference-when-are-objects-saved-questionmark">什么时候保存对象</h4>

<p>把对象赋值给 <code>has_and_belongs_to_many</code> 关联时，会自动保存对象（因为要更新外键）。如果一次赋值多个对象，所有对象都会自动保存。</p>

<p>如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 <code>false</code>，赋值操作会取消。</p>

<p>如果父对象（<code>has_and_belongs_to_many</code> 关联声明所在的模型）没保存（<code>new_record?</code> 方法返回 <code>true</code>），那么子对象也不会保存。只有保存了父对象，才会保存子对象。</p>

<p>如果赋值给 <code>has_and_belongs_to_many</code> 关联时不想保存对象，可以使用 <code>collection.build</code> 方法。</p>

<h3 id="association-callbacks">关联回调</h3>

<p>普通回调会介入 Active Record 对象的生命周期，在很多时刻处理对象。例如，可以使用 <code>:before_save</code> 回调在保存对象之前处理对象。</p>

<p>关联回调和普通回调差不多，只不过由集合生命周期中的事件触发。关联回调有四种：</p>

<ul>
  <li><code>before_add</code></li>
  <li><code>after_add</code></li>
  <li><code>before_remove</code></li>
  <li><code>after_remove</code></li>
</ul>

<p>关联回调在声明关联时定义。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">before_add: :check_credit_limit</span>

  <span class="k">def</span> <span class="nf">check_credit_limit</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>Rails 会把添加或删除的对象传入回调。</p>

<p>同一事件可触发多个回调，多个回调使用数组指定：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span>
    <span class="ss">before_add: </span><span class="o">[</span><span class="ss">:check_credit_limit</span><span class="p">,</span> <span class="ss">:calculate_shipping_charges</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">check_credit_limit</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">calculate_shipping_charges</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>如果 <code>before_add</code> 回调抛出异常，不会把对象加入集合。类似地，如果 <code>before_remove</code> 抛出异常，对象不会从集合中删除。</p>

<h3 id="association-extensions">关联扩展</h3>

<p>Rails 基于关联代理对象自动创建的功能是死的，但是可以通过匿名模块、新的查询方法、创建对象的方法等进行扩展。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span> <span class="k">do</span>
    <span class="k">def</span> <span class="nf">find_by_order_prefix</span><span class="p">(</span><span class="n">order_number</span><span class="p">)</span>
      <span class="n">find_by</span><span class="p">(</span><span class="ss">region_id: </span><span class="n">order_number</span><span class="o">[</span><span class="mi">0</span><span class="p">.</span><span class="nf">.</span><span class="mi">2</span><span class="o">]</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

</div>
<p>如果扩展要在多个关联中使用，可以将其写入具名扩展模块。例如：</p>

<div class="codeblock ruby"><pre class="highlight"><span class="k">module</span> <span class="nn">FindRecentExtension</span>
  <span class="k">def</span> <span class="nf">find_recent</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"created_at &gt; ?"</span><span class="p">,</span> <span class="mi">5</span><span class="p">.</span><span class="nf">days</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">extending</span> <span class="no">FindRecentExtension</span> <span class="p">}</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:deliveries</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">extending</span> <span class="no">FindRecentExtension</span> <span class="p">}</span>
<span class="k">end</span>
</pre>

</div>
<p>在扩展中可以使用如下 <code>proxy_association</code> 方法的三个属性获取关联代理的内部信息：</p>

<ul>
  <li><code>proxy_association.owner</code>：返回关联所属的对象；</li>
  <li><code>proxy_association.reflection</code>：返回描述关联的反射对象；</li>
  <li><code>proxy_association.target</code>：返回 <code>belongs_to</code> 或 <code>has_one</code> 关联的关联对象，或者 <code>has_many</code> 或 <code>has_and_belongs_to_many</code> 关联的关联对象集合；</li>
</ul>

                    </article>
                    <div class="section-nav clearfix">
  <div class="pull-left">
    
      <a href="http://docs-china.com/rails/active_record_callbacks.html" class="prev">
        &laquo;前一篇
      </a>
    
  </div>
  <div class="pull-right">
    
      <a href="http://docs-china.com/rails/active_record_quering.html" class="next">
        后一篇&raquo;
      </a>
    
  </div>
</div>

                </main>
                <div class="sidebar col-sm-3 col-md-3 hidden-xs">
                    <aside class="menu">
    
    <h4>起跑</h4>
    

<ul>

  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/getting_started.html">Rails 入门</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


</ul>

    
    <h4>模型</h4>
    

<ul>

  

  
    
  

  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/active_record_basics.html">Active Record 基础</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/migrations.html">Active Record 数据库迁移</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/active_record_validations.html">Active Record 数据验证</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/active_record_callbacks.html">Active Record 回调</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class="current"><a href="http://docs-china.com/rails/association_basics.html">Active Record 关联</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/active_record_querying.html">Active Record 查询</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


</ul>

    
    <h4>视图</h4>
    

<ul>

  

  
    
  

  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/action_view_overview.html">Action View 基础</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/layouts_and_rendering.html">Layouts and Rendering in Rails</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/form_helpers.html">表单帮助方法</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


</ul>

    
    <h4>控制器</h4>
    

<ul>

  

  
    
  

  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/action_controller_overview.html">Action Controller 简介</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/routing.html">Rails 路由全解</a></li>
    
  
    
  
    
  
    
  


</ul>

    
    <h4>深入</h4>
    

<ul>

  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/active_support_core_extensions.html">Active Support 核心扩展</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/i18n.html">Rails 国际化 API</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/action_mailer_basics.html">Action Mailer 基础</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/testing.html">Rails 程序测试指南</a></li>
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/security.html">Ruby on Rails 安全指南</a></li>
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/debugging_rails_applications.html">Rails 程序调试</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/configuring.html">Rails 程序设置</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/command_line.html">Rails 命令行</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/caching_with_rails.html">Caching with Rails An overview</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/asset_pipeline.html">Asset Pipeline</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/working_with_javascript_in_rails.html">在 Rails 中使用 JavaScript</a></li>
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/engines.html">Getting Started with Engines</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/initialization.html">Rails 初始化过程</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


</ul>

    
    <h4>扩展</h4>
    

<ul>

  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/plugins.html">Rails 插件开发基础</a></li>
    
  
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/rails_on_rack.html">Rails on Rack</a></li>
    
  
    
  
    
  
    
  
    
  


  

  
    
  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <li class=""><a href="http://docs-china.com/rails/generators.html">Creating and Customizing Rails Generators & Templates</a></li>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


</ul>

    
</aside>


                </div>
            </div>
        </div>
    </div>

    <footer class="footer" role="contentinfo">
        <div class="container">
            <div>
                <ul class="social">
                    <li class="github">
                        <a href="https://github.com/docs-china/rails/" title="在 GitHub 上关注我们">Github</a>
                    </li>
                    <li class="weibo">
                        <a href="http://weibo.com/docschina" title="关注我们的微博">@DocsChina</a>
                    </li>
                </ul>
            </div>

            <p>本文档授权协议：<a href="http://creativecommons.org/licenses/by-sa/4.0/deed.zh" title="CC BY-SA 4.0">CC BY-SA 4.0</a></p>
        </div>
    </footer>
</body>
</html>
